// SPDX-License-Identifier:  RPL-1.5 (Reciprocal Public) License
//
// (((((((((((((((((((((((((((((((((((       (((((((((((((((((((((((((((((((((((
// (((((((((((((((((((((((((((((((((((       (((((((((((((((((((((((((((((((((((
// (((((((((((((((((((((((((((((((((((       (((((((((((((((((((((((((((((((((((
// (((((((((((((((((((((((((((((((((((       (((((((((((((((((((((((((((((((((((
//
//
//
// (((((((((((((((((((((((((((                       (((((((((((((((((((((((((((
// (((((((((((((((((((((((((((((((               (((((((((((((((((((((((((((((((
// (((((((((((((((((((((((((((((((((           (((((((((((((((((((((((((((((((((
// ((((((((((((((((((((((((((((((((((         ((((((((((((((((((((((((((((((((((
//                     (((((((((((((((       (((((((((((((((
//                        ((((((((((((       ((((((((((((
//                         (((((((((((       (((((((((((
//                         (((((((((((       (((((((((((
//                         (((((((((((       (((((((((((
//                         (((((((((((       (((((((((((
//                         (((((((((((       (((((((((((
//
// FuelFoundry FUEL-721 MintController Contract
// Generated by: FuelFoundry
// More info at: https://fuelfoundry.io
// Code Release: 0.99.9
// All rights reserved
//
pragma solidity 0.8.23;

interface IERC721 {

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function transferFrom(address from, address to, uint256 tokenId) external;
    function safeMint(address to, uint256 tokenId) external payable;
    function mintEnabled() external view returns (bool mintEnabled_);
    function totalSupply() external view returns (uint256);
}

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract FuelMint is Ownable, ReentrancyGuard {

    IERC721 private _targetContract;

    // framework
    uint private _deploymentBlock = block.number;

    // fuelshield
    bool private _fallbackShield = true;
    bool private _mintShield = true;
    bool private _ownerShield = true;

    // governance
    address private _creatorPayoutWallet;
    address private _serviceProviderWallet;

    uint private _serviceProviderSBP;
    uint private _mintPriceTolerance;

    // token
    uint private _tokenIdStart;
    uint private _tokenIdEnd;
    uint private _tokenIdNext;

    uint public mintPrice;
    uint public nonce;
    uint public totalMinted;

    modifier onlyFabric() { require( _isFabricMember(), "!fabric"); _; }
    modifier onlySPW() { require( msg.sender == _serviceProviderWallet, "!spw"); _; }
    modifier onlySCW() { require( msg.sender == _serviceProviderWallet || msg.sender == _creatorPayoutWallet, "!spw||!cpw"); _; }

    enum Severity { Emergency, Alert, Critical, Error, Warning, Notice, Informational, Debug }
    enum Facility { Protocol, Governance, Executive, Operations, Oracle, External, Other }

    event Trap(
        uint nonce,                // nonce
        uint timestamp,            // block timestamp
        address  indexed origin,   // address that initiated event
        Facility indexed facility, // source that produced the event
        Severity indexed severity, // urgency of event
        string  application,       // function name or identified
        uint value,                // relative data
        string  message            // info about the event
    );


    /**
     * @dev FuelFoundry FUEL-721 MintController
     *
     * Definitions:
     *
     * - targetContract      - Mint contract target address
     * - _creatorPayoutWallet - Project creator payout address.
     * - serviceProviderWallet - Sale provider commission address.  Post deployment this may be updated via {setserviceProviderWallet}.
     * - mintPrice           - Mint price, constructor accepts value in ether.  Post deployment this may be updated using {setMintPrice} or in wei via {setMintPriceInWei}.
     * - serviceProviderSbp  - Fee for sale distribution to be sent to commission wallet.  Post deployment this may be adjusted via {setMintBasisPointsFee}.
     * - tokenIdStart        - Defines the first token id this mintctrl contract will mint.
     * - tokenIDEnd          - Defines the very last token id this specific mintctrl contract will mint and is not dependent on the token itself so be sure this does not exceed the asset's own maxSupply.
     *
     * Note:
     *
     * - maxSupply and tokenIdNext are programmatically defined however tokenIdNext may be adjusted via {exeTokenIdNextSet}.
     * - serviceProviderSbp represents a percentage derived from split-basis-points i.e.: 1 = 0.1%, 10 = 1%, 100 = 10%, 1000 = 100%
     * - tokenStart in most cases should 1, unless you're a solidity purest form the 0.5 or before days, you're welcome to make it 0.  You make also make it 101 etc.. depending on the use-case (range'd mintctrl, etc...)
     *
     */
    constructor(address __controllerOwner, address __creatorPayoutWallet, address __serviceProviderWallet, uint __serviceProviderSBP, uint __mintPriceInEther, IERC721 __targetContract, uint __tokenIdStart, uint __tokenIdEnd)
    Ownable(__controllerOwner) {

        // governance
        require (__controllerOwner != __creatorPayoutWallet, "owner may not equal CPW");
        require (__controllerOwner != __serviceProviderWallet, "owner may not equal SPW");
        require (__creatorPayoutWallet != __serviceProviderWallet, "CPW may not equal SPW");

        // token
        require(__tokenIdEnd >= __tokenIdStart, "__tokenIdEnd must be >= than __tokenIdStart");
        require(__serviceProviderSBP <= 1000, "__mintBasisPointsFee must be <= 1000");

        _creatorPayoutWallet = __creatorPayoutWallet;
        _serviceProviderWallet = __serviceProviderWallet;
        _serviceProviderSBP = __serviceProviderSBP;

        _targetContract = __targetContract;
        _tokenIdStart = __tokenIdStart;
        _tokenIdEnd = __tokenIdEnd;
        _tokenIdNext = __tokenIdStart;

        mintPrice = __mintPriceInEther * 1 ether;
    }


    //                     //
    //////  FUELPROXY  //////
    //                     //

    /**
     * @dev Returns the name of the target TNT721 contract.
     *
     * This function delegates the call to the `_targetContract`'s `name` method.
     * It is designed to fetch and return the name of the TNT721 contract that `_targetContract` points to.
     * This function is useful for external interfaces or other contracts that need to ascertain the name
     * of the TNT721 contract linked with this `FuelProxy` contract.
     *
     * @return string memory The name of the TNT721 contract.
     *
     * Requirements:
     * - `_targetContract` must be set and point to a valid TNT721 contract that implements the `name` function.
     */
    function name() public view returns (string memory) {

        return _targetContract.name();
    }


    /**
     * @dev returns the owner of the specified tokenId in the target TNT721 contract.
     * @param tokenId to query for ownership.
     * @return address of the token owner.
     *
     */
    function ownerOf(uint256 tokenId) public view returns (address) {

        return _targetContract.ownerOf(tokenId);
    }


    /**
     * @dev Returns the symbol of the target TNT721 contract.
     *
     * Similar to the `name` function, this function calls the `symbol` method of the `_targetContract`.
     * It retrieves the symbol of the TNT721 contract that `_targetContract` is referencing.
     * This is particularly useful for identifying the symbol associated with the TNT721 tokens
     * managed by the `FuelProxy` contract.
     *
     * @return string memory The symbol of the TNT721 contract.
     *
     * Requirements:
     * - `_targetContract` must be set to a valid TNT721 contract that has a `symbol` function.
     */
    function symbol() public view returns (string memory) {

        return _targetContract.symbol();
    }


    /**
     * @dev returns the tokenURI for the specified tokendId in the target TNT721 contract.
     * @param tokenId to query for metadata.
     * @return tokenUri string.
     *
     */
    function tokenURI(uint256 tokenId) public view returns (string memory) {

        return _targetContract.tokenURI(tokenId);
    }


    /**
     * @dev returns the totalSupply for the target TNT721 contract.
     * @return totalSupply.
     *
     */
    function totalSupply() public view returns (uint) {

        return _targetContract.totalSupply();
    }


    //                    //
    ////// GOVERNANCE //////
    //                    //

    /**
     * @dev checks if the caller is a member of the fabric.
     *
     * This internal function determines if the caller (`msg.sender`) is a member of the fabric. Membership is
     * defined by being either the contract owner, the creator payout wallet, or the service provider wallet.
     * It is used to enforce access control in various functions of the contract.
     *
     * @return isFabricMember_ Returns `true` if the caller is a fabric member (either the owner, the creator payout wallet,
     *         or the service provider wallet); otherwise, returns `false`.
     *
     * This function does not modify any state variables and is view-only, ensuring it does not consume gas when
     * used to query the blockchain.
     */
    function _isFabricMember() internal view returns (bool isFabricMember_) {

        if (msg.sender == super.owner() || msg.sender == _creatorPayoutWallet || msg.sender == _serviceProviderWallet) {

            return true;
        } else {

            return false;
        }
    }


    //                  //
    //////   GETS   //////
    //                  //

    /**
     * @dev Retrieves the next token ID to be used for minting.
     *
     * This public view function returns the next token ID that is set to be used for the minting of new tokens.
     * This function is particularly useful for understanding the current state of token ID progression in the minting process.
     *
     * Access to this function is restricted to members with `onlyFabric` permissions, ensuring that only authorized
     * individuals or entities can query this sensitive information.
     *
     * @return tokenIdNext_
     */
    function tokenIdNext() public view onlyFabric returns (uint tokenIdNext_) {

        return _tokenIdNext;
    }


    /**
     * @dev returns all contract vars excluding controllers.
     *
     */
    function exeVars() public view onlyFabric returns (uint currentTimestamp_, uint deploymentBlock_, address targetContract_, uint nonce_, address owner_, address creatorPayoutWallet_, address _serviceProviderWallet_, uint serviceProviderSBP_, uint mintPriceInEther_, uint mintPriceInWei_, uint mintPriceToleranceInWei_, uint tokenIdStart_, uint tokenIdEnd_, uint tokenIdNext_, uint maxSupply_, uint remainingSupply_, bool mintShield_, bool ownerShield_, uint totalMinted_) {

        return (block.timestamp, _deploymentBlock, address(_targetContract), nonce, super.owner(), _creatorPayoutWallet, _serviceProviderWallet, _serviceProviderSBP, mintPrice / 1e18, mintPrice, _mintPriceTolerance, _tokenIdStart, _tokenIdEnd, _tokenIdNext, maxSupply(), remainingSupply(), _mintShield, _ownerShield, totalMinted);
    }


    //                  //
    //////   SETS   //////
    //                  //

    /**
     * @dev sets a new address for the creator payout wallet.
     *
     * This function allows the contract owner to update the address of the creator payout wallet.
     * It is protected by the `nonReentrant` modifier to prevent reentrancy attacks and can only be called by the contract owner.
     * A requirement is enforced to ensure that the current creator payout wallet is the one initiating this change.
     *
     * Emits a `Trap` event upon successfully updating the creator payout wallet.
     *
     * @param __newCreatorPayoutWallet The new address to be set as the creator payout wallet.
     *
     * Requirements:
     * - The caller must be the contract owner.
     * - The caller must be the current spw or creator payout wallet.
     *
     * @notice The function will revert if called by any address other than the current creator payout wallet.
     */
    function exeUpdateCPW(address __newCreatorPayoutWallet) public onlyOwner onlySCW nonReentrant {

        _creatorPayoutWallet = __newCreatorPayoutWallet;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Governance, Severity.Alert, "UpdateCPW", uint160(_creatorPayoutWallet), string(abi.encodePacked("creator payout wallet updated to: ", _addressToAscii(_creatorPayoutWallet))));
    }


    /**
     * @dev sets a new address for the service provider wallet.
     *
     * This function allows the contract owner to update the address of the service provider wallet.
     * It is protected by the `nonReentrant` modifier to prevent reentrancy attacks and can only be called by the contract owner.
     * A requirement is enforced to ensure that the current service provider wallet is the one initiating this change.
     *
     * Emits a `Trap` event upon successfully updating the service provider wallet.
     *
     * @param __newServiceProviderWallet The new address to be set as the service provider wallet.
     *
     * Requirements:
     * - The caller must be the contract owner.
     * - The caller must be the current service provider wallet.
     *
     * @notice The function will revert if called by any address other than the current service provider wallet.
     */
    function exeUpdateSPW(address __newServiceProviderWallet) public onlyOwner nonReentrant {

        _serviceProviderWallet = __newServiceProviderWallet;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Governance, Severity.Alert, "UpdateSPW", uint160(_serviceProviderWallet), string(abi.encodePacked("service provider wallet updated to: ", _addressToAscii(_serviceProviderWallet))));
    }


    /**
     * @dev sets new target contract.
     *
     * This public function allows for updating the reference to the target contract which must be of IERC721 type.
     * This is used to change the contract with which this contract interacts for operations related to ERC721 tokens.
     *
     * The function includes non-reentrancy protection and is restricted to authorized roles through the `onlyFabric` modifier.
     *
     * @param __newTargetContract The new target contract of IERC721 type to be set.
     *
     * Requirements:
     * - The caller must have the appropriate authorization (`onlyFabric`).
     *
     * @notice This function updates the reference to the target ERC721 contract.
     *
     * Upon successful execution, the target contract is updated, and an event is emitted containing the contract's address.
     */
    function exeTargetContractSet(IERC721 __newTargetContract) public onlyFabric nonReentrant {

        _targetContract = __newTargetContract;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Informational, "TargetContractSet", uint160(address(_targetContract)), string(abi.encodePacked("commission wallet updated to: ", _addressToAscii(address(_targetContract)))));
    }


    /**
     * @dev Sets a new mint price tolerance.
     *
     * This function allows for updating the tolerance level for mint price changes. The tolerance is set in Ether.
     * It is used to limit how much the mint price can be altered, providing a safeguard against significant, unintentional price fluctuations.
     *
     * @param __newMintPriceToleranceInEther The new mint price tolerance, specified in Ether.
     *
     * Requirements:
     * - The caller must have the necessary authorization, enforced by `onlyFabric`.
     * - Optionally, you can add conditions to ensure the tolerance value is within a specific range.
     *
     * @notice The tolerance value is stored in Wei for consistency and precision.
     */
    function exeMintToleranceSet(uint __newMintPriceToleranceInEther) public onlyFabric nonReentrant {

        // store tolerance in wei
        uint newToleranceInWei = __newMintPriceToleranceInEther * 1 ether;
        _mintPriceTolerance = newToleranceInWei;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Informational, "MintPriceToleranceSet", _mintPriceTolerance, "Mint price tolerance in ether updated");
    }


    /**
     * @dev sets the mint price with an enforced tolerance limit.
     *
     * This public function allows for updating the mint price of a contract. The update is subject to a tolerance limit,
     * which restricts the percentage by which the mint price can be altered. This is to prevent drastic changes in the price.
     *
     * The function includes non-reentrancy protection and is restricted to authorized roles through the `onlyFabric` modifier.
     *
     * @param __newMintPriceInEther The new mint price to be set, in Ether.
     *
     * Requirements:
     * - The caller must have the appropriate authorization (`onlyFabric`).
     * - `__newMintPriceInEther` must be greater than or equal to 1.
     * - If the tolerance is set (greater than 0), the new price must be within the specified tolerance range of the current mint price.
     *   The current tolerance value can be retrieved using `getVars()`.
     *
     * @notice If the tolerance check is enabled and the new price is outside the allowed range, the transaction will revert.
     *
     * The updated mint price is recorded in Wei, and an event is emitted upon successful execution.
     */
    function exeMintPriceSet(uint __newMintPriceInEther) public onlyFabric nonReentrant {

        require(__newMintPriceInEther >= 1, "__newMintPriceInEther must be > 0");

        mintPrice = __newMintPriceInEther * 1 ether;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Informational, "MintPriceSet", mintPrice, "mint price updated in ether (value recorded in wei)");
    }

    /**
     * @dev Safely sets the mint price with an enforced tolerance limit.
     *
     * This function allows for the secure update of the mint price in a contract, ensuring changes are within a predefined tolerance range.
     * The tolerance mechanism is designed to prevent significant, unintentional fluctuations in the mint price, thereby safeguarding the contract's stability.
     *
     * Key features:
     * - Non-reentrancy protection to prevent reentrant calls.
     * - Access control via the `onlyFabric` modifier, ensuring that only authorized roles can execute this function.
     * - The new mint price, expressed in Ether, must be at least 1 Ether.
     * - If a tolerance limit is set (greater than 0), the new price must not deviate beyond this limit from the current mint price.
     *   This tolerance limit helps in maintaining pricing consistency and trust.
     * - The updated mint price is recorded in Wei for precision.
     * - An event (`Trap`) is emitted to log the action, providing transparency and traceability.
     *
     * @param __newMintPriceInEther The intended new mint price, specified in Ether.
     *
     * Requirements:
     * - The caller must have the necessary authorization, enforced by `onlyFabric`.
     * - `__newMintPriceInEther` must be greater than or equal to 1 Ether.
     * - The new price must adhere to the tolerance limits if set. Use `getVars()` to check the current tolerance value.
     *
     * @notice A transaction will revert if it fails the tolerance check, ensuring price changes remain within acceptable bounds.
     */
    function exeMintPriceSafeSet(uint __newMintPriceInEther) public onlyFabric nonReentrant {

        require(__newMintPriceInEther >= 1, "__newMintPriceInEther must be > 0");

        uint _newMintPriceInWei = __newMintPriceInEther * 1 ether;

        if (_mintPriceTolerance > 0) {

            require(mintPrice >= _mintPriceTolerance, "Current mint price is lower than tolerance level");

            uint _lowerBound = mintPrice > _mintPriceTolerance ? mintPrice - _mintPriceTolerance : 1 ether;
            require(_newMintPriceInWei >= _lowerBound, "New price must be within tolerance of the current mint price. See getVars() for tolerance value");
        }

        mintPrice = _newMintPriceInWei;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Informational, "MintPriceSafeSet", mintPrice, "Mint price updated in ether (value recorded in wei)");
    }


    /**
     * @dev sets mint price in Wei.
     *
     * This public function allows for directly setting the mint price in Wei, the smallest unit of Ether.
     * This provides precise control over the mint price, avoiding the need for conversions from Ether.
     *
     * The function includes non-reentrancy protection and is restricted to authorized roles through the `onlyFabric` modifier.
     *
     * @param __newMintPriceInWei The new mint price to be set, in Wei.
     *
     * Requirements:
     * - The caller must have the appropriate authorization (`onlyFabric`).
     * - `__newMintPriceInWei` must be greater than or equal to 0.001 TFuel (1e15 Wei).
     *
     * @notice The function will revert if the new mint price in Wei is less than the specified minimum.
     *
     * Upon successful update, the new mint price in Wei is set, and an event is emitted.
     */
    function exeMintPriceInWeiSet(uint __newMintPriceInWei) public onlyFabric nonReentrant {

        require(__newMintPriceInWei >= 1e15, "__newMintPriceInWei must be >= 0.001 TFuel");

        mintPrice = __newMintPriceInWei;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Informational, "MintPriceInWeiSet", mintPrice, "mint price updated in wei");
    }


    /**
     * @dev sets next tokenId for minting.
     *
     * This public function allows for setting the next token ID that will be used for minting. It ensures that
     * the new token ID is within the predefined range and checks that the token ID does not already exist in the
     * target contract. The minting process must be paused (via `_mintShield`) to update this value.
     *
     * The function includes non-reentrancy protection and is restricted to authorized roles through the `onlyFabric` modifier.
     *
     * @param __tokenIdNext The next token ID to be set for minting.
     *
     * Requirements:
     * - The caller must have the appropriate authorization (`onlyFabric`).
     * - Minting must be paused (`_mintShield` must be true).
     * - `__tokenIdNext` must be within the range of `_tokenIdStart` and `_tokenIdEnd`.
     * - The `__tokenIdNext` must not already exist in the target contract.
     *
     * @notice The function will revert if minting is not paused, if the `__tokenIdNext` is outside the allowed range,
     *         or if the token ID already exists in the target contract.
     *
     * Upon successful execution, the next token ID is updated, and a critical severity event is emitted.
     */
    function exeTokenIdNextSet(uint __tokenIdNext) public onlyFabric nonReentrant {

        require(_mintShield, "mint must be paused to update value");
        require(__tokenIdNext <= _tokenIdEnd, "_tokenIdNext must be <= tokenIdEnd");
        require(__tokenIdNext >= _tokenIdStart, "_tokenIdNext must be >= than tokenIdStart");

        // if token exists, don't allow function to complete
        try _targetContract.ownerOf(__tokenIdNext) {

            // if the call does not fail, token exists, revert the transaction.
            revert("Token ID already exists");
        } catch {

            // if the call fails, the token ID does not exist, proceed.
        }

        _tokenIdNext = __tokenIdNext;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Critical, "TokenIdNextSet", _tokenIdNext, "next token id updated");
    }


    /**
     * @dev sets start tokenId number.
     *
     * Requirements:
     *
     * - may only be performed by a fabric member, use with caution as this could break minting
     * - minting must be paused to update value
     *
     * Note: This should never be used unless the contract was setup incorrectly.
     *
     */
    function exeTokenIdStartSet(uint __tokenIdStart) public onlyFabric nonReentrant {

        require(_mintShield, "mint must be paused (mintShield enabled) to update value");
        require(_tokenIdStart <= _tokenIdEnd, "_tokenIdStart must be <= tokenIdEnd");

        _tokenIdStart = __tokenIdStart;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Critical, "TokenIdStartSet", _tokenIdStart, "token id start updated");
    }


    /**
     * @dev Sets the end token ID for the contract.
     *
     * This function updates the `_tokenIdEnd` state variable to a new value, effectively setting the upper limit for token IDs.
     * It is intended to define the range of valid token IDs that can be minted or managed by the contract.
     *
     * Requirements:
     * - Can only be called by a member of the fabric (enforced by the `onlyFabric` modifier).
     * - The new token ID end (`__newTokenIdEnd`) must be greater than or equal to the starting token ID (`_tokenIdStart`).
     * - The function is `nonReentrant` to prevent re-entrancy attacks.
     *
     * Emits a `Trap` event upon successful update, signaling a critical operational change in the contract.
     *
     * @param __newTokenIdEnd The new end token ID to be set, which must be >= the current start token ID.
     */
    function exeTokenIdEndSet(uint __newTokenIdEnd) public onlyFabric nonReentrant {

        require(__newTokenIdEnd >= _tokenIdStart, "_tokenIdEnd must be >= tokenIdStart");

        _tokenIdEnd = __newTokenIdEnd;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Critical, "TokenIdEndSet", _tokenIdEnd, "token id end updated");
    }


    /**
     * @dev calls safeMint function of targetContract and explicitly provided token id to mint while collecting and distributing payment respectively
     *
     * Requirements:
     *
     * - `__to` destination address of final asset to be passed to safeMint function of asset contract
     * - Ensure target contract `safeMint` function being called is limited to mintController / authorized contracts only and there is no token id range overlap
     *
     * Notes:
     *
     * - Fee payout breakdown in split-basis-points, i.e.: 123/1000=12.3%, 666/1000=66.6%, 10/1000=1%
     * - ABI: [{"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"safeMint","outputs":[{"internalType":"bool","name":"success_","type":"bool"}],"stateMutability":"payable","type":"function"}]
     *
     */
    function _safeMint(address __to) internal {

        require(!_mintShield, "mintShield enabled, mint paused");
        require(_tokenIdNext <= _tokenIdEnd, "no tokens left to mint");
        require(msg.value >= mintPrice, "insufficient tfuel payment");

        uint _commissionFee = msg.value * _serviceProviderSBP / 1000;
        uint _payoutTotal = msg.value - _commissionFee;

        if (_serviceProviderSBP == 0) {

            _commissionFee = 0;
            _payoutTotal = msg.value;
        }

        if (_commissionFee > 0) {

            payable(_serviceProviderWallet).transfer(_commissionFee);
        }

        if (_payoutTotal > 0 ) {

            payable(_creatorPayoutWallet).transfer(_payoutTotal);
        }

        // call controller only accessible safeMint external function in target contract (ensure target has controllers in place to limit access)
        try _targetContract.safeMint(__to, _tokenIdNext) {
            // success
        } catch (bytes memory reason) {

            revert(string(reason));
        }

        _tokenIdNext += 1;
        totalMinted += 1;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Informational, "safeMint", msg.value, "token minted successfully");
    }


    /**
     * @dev External function to mint a new token to a specified address.
     *
     * This function is an external interface for minting tokens. It delegates the minting process to the internal `_safeMint` function.
     * Being `payable`, it allows for Ether transfers to the contract, which can be used for minting with payment.
     *
     * @param __to The address to which the new token will be minted.
     *
     * Requirements:
     * - The function is non-reentrant to prevent reentrancy attacks.
     */
    function safeMint(address __to) external payable nonReentrant {

        _safeMint(__to);
    }


    /**
     * @dev Internal function to handle the safe minting of tokens.
     *
     * This function performs various checks before minting a token, such as mint shield status, token ID availability, and payment sufficiency.
     * It also handles the distribution of the mint payment, dividing it between the service provider and the creator.
     *
     * @param __to The address to receive the minted token.
     * @param __singleMintPayment The payment received for minting one token.
     *
     * Requirements:
     * - Minting should not be paused (`_mintShield` should be disabled).
     * - There must be tokens left to mint (`_tokenIdNext` should be within the limit).
     * - The payment must be equal to or exceed the set mint price.
     *
     * Emits a `Trap` event upon successful minting.
     */
    function _safeMint(address __to, uint256 __singleMintPayment) internal {

        require(!_mintShield, "mintShield enabled, mint paused");
        require(_tokenIdNext <= _tokenIdEnd, "no tokens left to mint");
        require(__singleMintPayment >= mintPrice, "insufficient tfuel payment");

        uint256 _commissionFee = __singleMintPayment * _serviceProviderSBP / 1000;
        uint256 _payoutTotal = __singleMintPayment - _commissionFee;

        if (_commissionFee > 0) {

            payable(_serviceProviderWallet).transfer(_commissionFee);
        }

        if (_payoutTotal > 0 ) {

            payable(_creatorPayoutWallet).transfer(_payoutTotal);
        }

        try _targetContract.safeMint(__to, _tokenIdNext) {

            // success
        } catch (bytes memory reason) {

            revert(string(reason));
        }

        _tokenIdNext += 1;
        totalMinted += 1;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Informational, "safeMint", __singleMintPayment, "token minted successfully");
    }


    /**
     * @dev External function to mint multiple tokens to a specified address.
     *
     * Allows for the minting of multiple tokens in a single transaction. It calls the internal _safeMint function for each token
     * to be minted. The function checks if the total payment is sufficient for the number of tokens requested to mint.
     * @param __to The address to which the new tokens will be minted.
     * @param __quantity The number of tokens to mint.
     *
     * Requirements:
     * - Quantity must be greater than zero.
     * - Total payment must be sufficient to cover the minting cost of the requested quantity (based on `mintPrice`).
     * - Function is non-reentrant to prevent reentrancy attacks.
     *
     * The function divides the total payment by the quantity to calculate the payment for each token and mints them one by one.
    */
    function safeMint(address __to, uint __quantity) external payable nonReentrant {

        require(__quantity > 0, "Quantity must be greater than zero");
        require(msg.value >= mintPrice * __quantity, "Total payment is insufficient");

        uint256 _singleMintPayment = msg.value / __quantity;

        for (uint i = 0; i < __quantity; i++) {

            _safeMint(__to, _singleMintPayment);
        }
    }


    /**
     * @dev sets the service provided SBP.
     *
     * This public function allows for setting the fee basis points charged by the service provider. The fee is
     * specified in basis points, where 100 basis points equal 1%. This function allows setting the fee up to a
     * maximum of 1000 basis points (10%).
     *
     * The function includes non-reentrancy protection and is restricted to the service provider wallet through the `onlySPW` modifier.
     *
     * @param __newServiceProviderSBP The new service provider's fee in basis points to be set.
     *
     * Requirements:
     * - The caller must be the service provider wallet (`onlySPW`).
     * - `__newServiceProviderSBP` must be less than or equal to 1000 (10%).
     *
     * @notice The function will revert if the new fee in basis points exceeds 1000 (10%).
     *
     * Upon successful execution, the service provider's fee basis points are updated, and an alert severity event is emitted.
     *
     */
    function spwUpdateSBP(uint __newServiceProviderSBP) public onlySPW nonReentrant {

        require(__newServiceProviderSBP <= 1000, "__newServiceProviderSbp must be <= 1000");

        _serviceProviderSBP = __newServiceProviderSBP;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Executive, Severity.Alert, "UpdateSBP", _serviceProviderSBP, "mint fee updated");
    }


    /**
     * @dev changes mint pause state
     *
     * Requirements:
     *
     * - must be a fabric member to call.
     *
     * Note: This only updates pause state on the mintController contract.
     *
     */
    function exeMintToggle() public onlyFabric nonReentrant {

        _mintShield = !_mintShield;

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Notice, "MintToggle", _mintShield ? 1:0, _mintShield ? "mintShield enabled, minting disabled [controller]":"mintShield disabled, minting enabled [controller]");
    }


    //                                  //
    ////// MARKETPLACE INTEGRATIONS //////
    //                                  //

    /**
     * @dev Retrieves the current mint price of tokens.
     *
     * This function returns the current price set for minting new tokens. It includes an
     * additional check to ensure that the minting process is still active. If all tokens
     * designated for minting have already been issued (i.e., `tokenIdNext` has surpassed
     * `tokenIdEnd`), the function reverts, indicating that the sale has ended.
     *
     * The check for `tokenIdNext <= tokenIdEnd` ensures that the sale is ongoing. If this
     * condition is not met, it implies that all tokens within the specified range have
     * already been minted, and thus no more tokens are available for sale.
     *
     * @return mintPrice_ The current price which tokens are being minted.
     * @notice The function reverts with "sale has ended" if `tokenIdNext` exceeds `tokenIdEnd`.
     *
     */
    function getMintPrice() external view returns (uint mintPrice_) {

        require(_tokenIdNext <= _tokenIdEnd, "sale has ended");

        return mintPrice;
    }


    /**
     * @dev Checks the current status of minting capabilities in the contract.
     *
     * This function provides information about two minting-related flags:
     * - `mintEnabledController_`: Indicates the status of the minting controller's ability to enable or disable minting.
     * - `mintEnabledContract_`: Reflects the minting status directly from the target contract.
     *
     * The function returns two boolean values indicating the state of these minting flags.
     * The `_mintShield` state is negated to interpret its status (usually, if `_mintShield` is `true`, minting is disabled).
     *
     * @return mintEnabledController_ The negated state of `_mintShield`, indicating the minting controller's status.
     * @return mintEnabledContract_ The current minting status as reported by the `_targetContract`.
     *
     */
    function mintEnabled() external view returns (bool mintEnabledController_, bool mintEnabledContract_) {

        return (!_mintShield, _targetContract.mintEnabled());
    }


    /**
     * @dev Calculates and returns the remaining number of tokens that can still be minted.
     *
     * This function computes the difference between the `tokenIdEnd` and the `tokenIdNext`
     * to determine how many more tokens are available for minting. It includes the `tokenIdNext`
     * itself in the count, hence the addition of 1.
     *
     * The calculation assumes that the `tokenIdNext` is the next token to be minted and that
     * minting proceeds sequentially up to `tokenIdEnd`.
     *
     * @return remainingSupply_ The total number of tokens that are still available for minting,
     *                          calculated as `tokenIdEnd - tokenIdNext + 1`.
     *
     */
    function remainingSupply() public view returns (uint remainingSupply_) {

        return _tokenIdEnd - _tokenIdNext + 1;
    }


    /**
     * @dev Calculates and returns the maximum supply of tokens available for minting.
     *
     * This function calculates the maximum number of tokens that can be minted by the contract
     * based on the range defined between `tokenIdStart` and `tokenIdEnd`.
     *
     * @return maxSupply_ The total number of mintable tokens defined by the contract, which is
     *                    the inclusive range between `tokenIdStart` and `tokenIdEnd`.
     *
     */
    function maxSupply() public view returns (uint maxSupply_) {

        return (_tokenIdEnd - _tokenIdStart + 1);
    }


    //                   //
    ////// FUELTOOLS //////
    //                   //

    /**
     * @dev Converts an address to an ascii string
     *
     * Note: Gas intensive, do not use in a loop, this is primarily used for reporting
     *
     * Requirements:
     *
     * - `x` address specified is the address returned as string.
     *
     */
    function _addressToAscii(address x) internal pure returns (string memory) {

        bytes memory s = new bytes(40);

        for (uint i = 0; i < 20; i++) {

            bytes1 b = bytes1(uint8(uint160(x) / (2**(8*(19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2*i] = _char(hi);
            s[2*i+1] = _char(lo);
        }

        return string(s);
    }


    /**
     * @dev Converts a 4-bit number (a nibble) into its ascii representation as a hexadecimal char.
     *
     * Requirements:
     *
     * - Takes a single bytes1 argument `b` and returns a bytes1 char representation `c` of a hexadecimal digit.
     *
     */
    function _char(bytes1 b) internal pure returns (bytes1 c) {

        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }


    /**
     * @dev Generates a nonce
     *
     * Note: Internal function
     *
     */
    function _nonce() internal returns (uint nonce_) {

        nonce = (nonce < type(uint).max) ? nonce + 1 : 0;

        return nonce;
    }


    /**
     * @dev generates uint based on a unique hash based on various blockchain parameters and the contract's state.
     *
     * This external view function combines several blockchain parameters and contract-specific values
     * to create a unique hash. It encodes the block number, timestamp, gas limit, chain ID, contract's address,
     * its balance, the block's coinbase address, and a nonce, then hashes this data using keccak256.
     *
     * @return fuelGeneratedIdCode_ A uint representing the generated hash, unique to the current state and blockchain context.
     *
     * Note: This function is read-only and does not modify the state of the contract.
     */
    function fuelCode() external view returns (uint fuelGeneratedIdCode_) {

        return uint(keccak256(abi.encodePacked(block.number, block.timestamp, block.gaslimit, block.chainid, address(this), address(this).balance, nonce)));
    }


    /**
     * @dev returns current chain block number
     *
     */
    function currentBlockNumber() public view returns (uint currentBlockNumber_) { return block.number; }


    /**
     * @dev returns current chain epoch time
     *
     */
    function currentBlockEpoch() public view returns (uint currentBlockTime_) { return block.timestamp; }


    /**
     * @dev returns current chain block and epoch time in same call
     *
     */
    function currentBlockAndEpoch() public view returns (uint currentBlockNumber_, uint currentBlockTime_) { return (block.number, block.timestamp); }


    /**
     * @dev For anyone feeling generous
     *
     * Note: Used to validate payment distribution split w/o minting assets
     *
     */
    function donate() public payable nonReentrant {

        require(msg.value >= 1e15, "error: value mismatch, minimum donation is 1 pwei (0.001 TFuel)");

        uint _commissionFee = msg.value * _serviceProviderSBP / 1000;
        uint _payoutTotal = msg.value - _commissionFee;

        if (_commissionFee > 0) {

            payable(_serviceProviderWallet).transfer(_commissionFee);
        }

        if (_payoutTotal > 0 ) {

            payable(_creatorPayoutWallet).transfer(_payoutTotal);
        }

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Operations, Severity.Informational, "donate", msg.value, "donation made");
    }


    /**
     * @dev Returns TFuel balance
     *
     */
    function balanceTFuel() public view onlyFabric returns (uint) {

        return address(this).balance;
    }


    /**
     * @dev Returns TNT-20 balance
     *
     * Requirements:
     *
     * - `tokenContract` for respective token to inquire balanceOf.
     *
     */
    function balanceTNT20(address tokenContract) public view onlyFabric returns (uint) {

        IERC20 token = IERC20(tokenContract);

        return token.balanceOf(address(this));
    }


    /**
     * @dev if funds are accidentally sent to this contract, this allows for the funds to be withdrawn and returned
     *
     * Requirements:
     *
     * - must be contract owner to call.
     *
     */
    function withdrawTFuel(address payable to, uint amount) public onlyOwner nonReentrant {

        require(address(this).balance >= amount, "insufficient balance");

        to.transfer(amount);

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Protocol, Severity.Alert, "withdraw", amount, string(abi.encodePacked("withdraw to wallet: ", _addressToAscii(to))));
    }


    /**
     * @dev if other funds are accidentally sent to this contract, this allows for said funds to be withdrawn and returned
     *
     * Requirements:
     *
     * - must be contract owner to call.
     *
     */
    function withdrawTNT20(address tokenContract, address to, uint256 amount) public onlyOwner nonReentrant {

        IERC20 token = IERC20(tokenContract);

        require(token.transfer(to, amount), "transfer failed");

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Protocol, Severity.Alert, "withdrawTNT20", amount, string(abi.encodePacked("withdrawTNT20 to wallet: ", _addressToAscii(to))));
    }


    /**
     * @dev Withdraws NFT from the contract.
     * @param tokenContract address of the ERC-721 token contract.
     * @param tokenId of the token to be withdrawn.
     * @param to address to which the token should be sent.
     *
     */
    function withdrawNFT(address tokenContract, uint256 tokenId, address to) external onlyOwner nonReentrant {

        IERC721 nftContract = IERC721(tokenContract);

        require(nftContract.ownerOf(tokenId) == address(this), "Token not owned by contract");

        nftContract.transferFrom(address(this), to, tokenId);
    }


    //                  //
    ////// PROTOCOL //////
    //                  //

    /**
     * @dev owner function override to keep wandering eyes wandering
     *
     * Note:
     *
     * - Fabric members will still be able to query owner
     * - This is still visible on the blockchain
     *
     */
    function owner() public view override returns (address) {

        if (!_ownerShield) {

            return super.owner();
        } else if (_isFabricMember()) {

            return address(super.owner());
        } else {

            return address(0);
        }
    }


    /**
     * @dev Disables the renounce ownership function.
     *
     * Note: This function is overridden to prevent renouncing ownership.
     *
     */
    function renounceOwnership() public view override onlyOwner {

        revert("renouncing ownership is disabled");
    }


    /**
     * @dev Overrides the transferOwnership function to restrict ownership transfer
     * to the creatorPayoutWallet or serviceProviderWallet.
     * @param newOwner Address of the new owner
     *
     */
    function transferOwnership(address newOwner) public override onlyOwner nonReentrant {

        require(newOwner == _creatorPayoutWallet || newOwner == _serviceProviderWallet, "unauthorized transfer address");

        super.transferOwnership(newOwner);
    }


    /**
     * @dev fallback function for receiving TFuel and handling data calls that do not match any function.
     *
     * This external payable function is non-reentrant and is invoked when a transaction with TFuel
     * is sent to the contract without specifying a function call, or if the data does not match any function signature.
     * The function can be disabled via a boolean guard, and records an incident if disabled.
     *
     * Requirements:
     * - Fallback is enabled (checked via the `fallbackShield` boolean).
     *
     * @notice This function will revert if the `fallbackShield` is true, indicating the fallback is disabled.
     *
     */
    fallback() external payable nonReentrant {

        require(!_fallbackShield, "this incident has been reported");

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Protocol, Severity.Alert, "fallback", msg.value, "fallback function called");
    }


    /**
     * @dev receive function for directly receiving TFuel transfers.
     *
     * This external payable function is non-reentrant, called when TFuel is sent directly to the contract
     * without data. It's used primarily for simple TFuel transfers and logs the receipt of TFuel.
     *
     * Note: This function does not have any conditions and always accepts TFuel transfers.
     *
     */
    receive() external payable nonReentrant {

        emit Trap(_nonce(), block.timestamp, msg.sender, Facility.Protocol, Severity.Alert, "receive", msg.value, "receive function called");
    }
}